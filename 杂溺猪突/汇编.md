# 汇编

---

### 一、预备知识

**汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作。**

> 机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字，计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。
>
> 汇编指令可以通过编译器翻译成机器指令。
>
> 指令和数据存放在内存中
>
> 指令和数据存放在内存中是没有区别的，都是以二进制存储
>
> 内存编号是从 0 开始的
>
> 内存的最小单元是字节，2 个十六进制位，1byte = 8bit
>
> CPU 中也存放了一部分指令和数据
>
> 地址线决定了 CPU 的寻址能力，即能够找到多大的地址，主要用来让 CPU 传送地址信息
>
> 数据线决定了 CPU 一次能够传送多少字节的数据，主要用来让 CPU 发送或接收数据
>
> 控制线决定了 CPU 对其他部件的控制能力。用来传输 CPU 发出的是读取还是写入命令。
>
> 例：1024 个内存单元的编号是从 0 ~ 1023，即 10 个 0 到 10 个 1 
>
> CPU 将内存条，显存，ROM 内存都看成内存空间，对内存空间进行了编号
>
> 内存有 ROM（只读存储器）和 RAM（随机存储器）形式
>
> CPU 通过端口去访问键盘、鼠标；通过内存地址去访问内存条、显存、ROM
>
> CPU 内部有保存地址信息和数据信息的地方，寄存器
>
> 8080，8088，80286，80386的地址总线宽度分别为 16 根，20 根，24 根，32 根，则他们的寻址能力分别为 64KB，1MB，16MB，4GB。
>
> 8080，8088，8086，80286，80386的数据总线宽度分别为 8 根，8 根，16 根，16 根，32 根，则他们依次可以传送的数据为 1Byte，1Byte，2Byte，2Byte，4Byte。



* 汇编语言有 3 类指令组成：

  1、汇编指令：机器码的助记符，有对应的机器码。

  2、伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

  3、其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码。

+ DOSBox 基础，debug 调试工具：
  + 输入 u 指令，将某个内存地址开始的机器指令翻译为汇编指令。`u 段地址:偏移地址` 显示指定内存地址开始的指令内容。
  + 输入 d 指令，将某个内存地址开始的字节全部当作数据。`d 段地址:偏移地址` 显示指定内存地址开始的数据内容。
  + 输入 e 指令，进入内存内容编辑模式，`e 段地址:偏移地址` 修改指定内存地址的内容。
  + 输入 r 指令，可以查看和修改寄存器中的内容
  + 输入 a 指令，可以以汇编指令的格式在内存中写入一条汇编指令。
  + 输入 t 指令，执行当前 cs:ip 所指向的一条指令

### 二、寄存器

> 汇编程序就是通过汇编语言中的汇编指令来修改寄存器中的内容，从而控制 CPU，来操作整个计算机。

+ AX、BX、CX、DX。16位寄存器， 范围 0 ~ 65535。通用寄存器，也叫数据寄存器。
+ AX = AH + AL，BX = BH + BL，CX = CH + CL，DX = DH + DL；8 位寄存器，范围 0 ~ 255。
+ 8086CPU 一次可以处理两种尺寸的数据：
  - 字节型数据  1Byte = 8bit，存放在 8 位寄存器中
  - 字型数据  2Byte = 16bit，存放在16位寄存器中 
+ MOV 指令，将逗号右边的数据、寄存器赋值给左边的寄存器，属于*传送指令*
+ ADD 指令，将逗号右边的值与左边的值相加，并把结果给逗号左边的值。
+ 在使用 MOV 时，要保证数据与寄存器、寄存器与寄存器之间位数的一致性
+ 16 位寄存器进行 16 位运算，保存 16 位数据；8 位寄存器进行 8 位运算，保存 8 位数据。
+ 地址加法器：段地址 * 16 + 偏移地址 = 物理地址，因为 8086CPU 有 20 根地址线，16 位寄存器无法表示，所以采用这种计算方式。
+ 段地址寄存器：`ds、es、ss、cs`
+ 偏移地址寄存器：`sp、bp、si、di、ip、bx`
+ 8086CPU 在任意时刻，将段地址寄存器 CS 和偏移地址寄存器 IP 组合出来的地址作为起始，从中读取的内容当作指令。
+ 指令是有长度的，一条指令可以由多个字节构成，IP 寄存器和指令长度有关系
+ 指令的执行过程
  1. CPU 从 CS:IP 所指向的内存单元读取指令，存放到指令缓存器中。
  2. IP = IP + 所读取指令的长度，从而指向下一条指令。
  3. 执行指令缓存器中的内容，回到步骤 1。
+ 汇编指令 `jmp`
  + 定义：转移指令，可以修改 cs 和 ip 这 2 个寄存器，决定了 CPU 从哪里读取指令
  + 用法：`jmp 段地址:偏移地址` ：
  + `jmp 寄存器` ：用寄存器中的值修改 IP。

### 三、寄存器（内存的访问）

+ 一个字型（word）数据，在内存中的存放，是由 2 个连续地址的内存单元组成，高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。

+ ds 段地址寄存器，访问数据的。

+ 栈空间是一段连续的内存单元，即一段连续的内存地址。栈的最大空间为 64KB。

+ 在 8086CPU 中，CPU 将段地址寄存器 SS 和偏移地址寄存器 SP 所组合出来的内存地址当作栈顶标记。

+ push ax：修改 sp 寄存器中的数值 sp = sp - 2；将 ax 中字型数据存入 ss:sp 所组合出来的内存地址中，即入栈。

+ pop bx：将 ss:sp 所组合出来的内存地址中的字型数据存入 bx，修改栈顶标记 sp = sp + 2，即出栈。

+ 数据寄存器 ds 和 es，一个可以指定为数据源，一个可以指定为数据目的地。

+ 循环指令：loop，区别于 jmp 指令，loop 按照设定的循环次数来执行。循环次数保存在 cx 寄存器中。loop 指令 2 个步骤：

   1.cx = cx -1；
   2.判断 cx 中的值，不为 0 则跳转到标号位置继续执行，等于 0 则执行后面的指令。

+ dw：define word，自定义字型数据。

+ db：define byte，自定义字节数据。

+ dd：define dword(double word),定义 32 位数据。

+ dup：`dd 10 dup(1)` 在一段连续的内存中定义十个相同的字节型数据 1。

+ bx：偏移地址寄存器

+ and：逻辑与，与 0 与，对应位置 0，与 1 与，对应位不变。

+ or：逻辑或，与 1 或，对应位置 1，与 0 或，对应位不变。

+ word ptr：定义寄存器数据类型为字型数据，例如：`mov word ptr ds:[bx],1`,将字型数据 0001 放入内存。

+ byte ptr：定义寄存器数据类型为字节型数据，例如：`mov byte ptr ds:[bx],1`，将字节型数据 01 放入内存。

+ div 指令，除法指令。

   + 除数：除数有 8 位和 16 位两种。在一个寄存器或内存单元中。
   + 被除数：默认放在 ax 或者 ax 和 dx 中。如果除数为 8 位，被除数则为 16 位，默认存放在 ax 中。如果除数为 16 位，被除数则为 32 位，ax 存放低 16 位，dx 存放高 16 位。
   + 结果：如果除数为 8 位，则 al 存放除法的商，ah 存放除法操作的余数。如果除数为 16 位，则 ax 存放除法操作的商，dx 存放除法操作的余数。

+ 立即数：十进制数字：1、145、12456 等，字符 'a'、'abcc' 等，方便阅读的字符。

+ 转移指令：可以修改 IP 或者同时修改 CS 和 IP。

+ OFFSET：返回给定标识符处的 IP 值。

+ jmp 跳转指令编译后的机器码和指令的长度有关，其实就是指令的长度。通过这么一种方式 CPU 在执行 jmp 指令的时候，不需要知道跳转的目的地址就可以实现对 ip 寄存器的修改。跳转目的 IP 地址 = jmp 指令高八位 + jmp下一个指令 IP 地址

+ jmp 跳转范围：`jmp short s`:8 位位移, -128 ~ 127. `jmp near ptr s`:16 位位移：-32768 ~ 32767.

+ NOP: cpu 遇到 nop 指令什么都不做，nop 占用一个字节。

+ jcxz：条件转移指令。j = jmp, cx = cx 寄存器，z = zero.用法：当 cx 寄存器中的值为 0 时，执行 jmp。

+ 所有的条件转移指令都是短转移，位移范围 -128 ~ 127.指令编译后的机器码中包含了位移值，如：**EBXX**，xx 的值编译器在编译的时候计算的，数值为：xx = 标号处的偏移地址 ip - jmp 指令后第一个字节的地址。

+ `jmp dword ptr ds:[0]`: dword 占用两个字型数据，所以 jmp 将 ds:[0] 指向的字型数据赋值给 ip，将 ds:[2] 指向的字型数据赋值给 cs。从而完成对 cs:ip 的设置。

+ `jmp word ptr ds:[0]`：word 为字型数据，所以 jmp 将 ds:[0] 指向的字型数据赋值给 ip.cs 不变。

+ jmp 标号；jmp short 标号；jmp near 标号；jcxz 标号；loop 标号。

+ ret：当执行 ret 指令时，相当于执行 pop ip

+ retf：当执行 retf 指令时，相当于先执行 pop ip，然后执行 pop cs。

+ call：先执行 `push ip`，再执行 `jmp near ptr 标号`, call 指令位移方式为 16 位位移。位移 = 标号处的偏移地址 - call 指令后第一个字节的地址。范围：-32768 ~ 32767.

+ call 标号：先执行 push ip，然后执行 jmp 标号。

+ call far ptr 标号：先执行 push cs，再执行 push ip，最后执行 jmp far ptr 标号。

+ call 16 位寄存器：先执行 push ip，然后执行 jmp 16 位寄存器。

+ call word ptr 内存单元地址，相当于执行了 push ip，jmp word ptr 内存单元地址。

+ call dword ptr 内存单元地址，相当于执行了先 push cs，再 push ip，最后 jmp dword ptr 内存单元地址。

   

  

   

   

   

   

   

   
  
   